<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Bear&#39;s home</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.polarbearmaster.com/"/>
  <updated>2017-04-20T14:47:59.000Z</updated>
  <id>blog.polarbearmaster.com/</id>
  
  <author>
    <name>Bear</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析一个奇怪的程序</title>
    <link href="blog.polarbearmaster.com/2017/04/19/%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>blog.polarbearmaster.com/2017/04/19/分析一个奇怪的程序/</id>
    <published>2017-04-19T15:27:06.000Z</published>
    <updated>2017-04-20T14:47:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分析下面的程序，思考：这个程序可以正确返回吗？</p>
</blockquote>
<pre><code>assume cs:code
code segment

        mov    ax,4c00h
        int 21h

start:    mov ax,0
    s:    nop
        nop

        mov di,offset s
        mov si,offset s2
        mov ax,cs:[si]
        mov cs:[di],ax

   s0:    jmp short s

   s1:    mov ax,0
        int 21h
        mov ax,0

   s2:    jmp short s1
        nop

code ends
end start
</code></pre><h2 id="查看CPU指令"><a href="#查看CPU指令" class="headerlink" title="查看CPU指令"></a>查看CPU指令</h2><p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fetilmteo5j20w00skwor.jpg" alt="image"></p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fetio409nnj21kw04lwgc.jpg" alt="image"></p>
<p>##指令执行顺序</p>
<ol>
<li><em>ip＝5</em>，执行代码中的     <code>mov ax,0</code></li>
<li>按<em>-t</em> 一直执行到<em>0014</em>     <code>mov cs:[di],ax</code></li>
<li>执行指令<em>0016</em>        <code>jmp short s (jmp 0008)</code></li>
<li>执行指令                <code>jmp 0000</code></li>
<li>执行指令<em>0000</em>            <code>mov ax,4c00h</code></li>
<li>执行指令<em>0003</em>            <code>int 21h</code></li>
</ol>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fetie4laxhj20zr0mgtbm.jpg" alt="image"></p>
<p>#结论：程序可以正常退出</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><pre><code>mov di,offset s
mov si,offset s2
mov ax,cs:[si]
mov cs:[di],ax
</code></pre><p><strong>这段代码的作用是将指令 s2 对应的指令当作数据存储 位于指令 s1 对应的地址处</strong></p>
<p>指令s2 对应的机器代码为 <em>EBF6</em><br>其中 <strong>EB</strong> 代表移动， <strong>F6</strong> 代表位移。</p>
<p><strong>执行完这条指令后，我们查看指令（按<code>-u cs:0</code>） 发现原本指令0C8D:<em>0008</em> 处的<em>90</em>（NOP）成为了 <em>EBF6</em> (<code>jmp 0000</code>)</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/bd582863gy1fetiqacjqij20mr0egabg.jpg" alt="image"></p>
<hr>
<h3 id="转移指令的作用"><a href="#转移指令的作用" class="headerlink" title="转移指令的作用"></a>转移指令的作用</h3><blockquote>
<ol>
<li>从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓存器;</li>
<li>(IP)=(IP)+所读取指令的长度，从而指向下一条指令;</li>
<li>执行指令。转到 1， 重复这个过程</li>
</ol>
</blockquote>
<p>F6是负值</p>
<p><code>Not(F6=11110110) + 1 = 1010b = 10</code></p>
<p><strong>即ip向前移动10个字节</strong></p>
<p>实际上读取指令 <code>s2: jmp short s1</code> 到缓存后</p>
<p>ip = <em>0022</em></p>
<p>之后 CPU 从缓存中读取s2指令，跳转到s1：<em>0018</em>处</p>
<p>同样可以得到 <strong>ip向前移动10个字节</strong> </p>
<p><code>22h-18h = 0ah = 10</code></p>
<hr>
<p>接下来 CPU 执行指令 <code>0016 s0:jmp short s</code></p>
<p>再跳转到指令s处</p>
<p>同上，CPU 读取指令 “ip向前移动10位” 到缓存中,</p>
<p>由于该指令存放在16位寄存器ax中，<strong>长度为2个字节</strong> </p>
<p>接着ip指向地址：<strong>000A</strong>，</p>
<p>接下来cpu从缓存中读取指令并执行，即<br><code>0ah － 10 ＝ 0</code></p>
<p>所以ip＝0，接着执行<br><code>mov ax，4c00h;
 int 21h;</code></p>
<p>#程序正常退出！！！</p>
<p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fetitjlcpyj20go0ciwhd.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析下面的程序，思考：这个程序可以正确返回吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;assume cs:code
code segment

        mov    ax,4c00h
        int 21h

s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>旋转棋盘</title>
    <link href="blog.polarbearmaster.com/2016/05/17/%E9%A2%98%E7%9B%AE%E4%BA%8C/"/>
    <id>blog.polarbearmaster.com/2016/05/17/题目二/</id>
    <published>2016-05-17T14:50:20.000Z</published>
    <updated>2016-05-22T03:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>There’re 9 numbers in a 3 x 3 plane. We could only clockwise or counterclockwise rotate the four tiles around one of the four points, I II III and IV. R1, R2, R3, R4 and r1, r2, r3, r4 are corresponding to the 8 kinds of rotation, where we mark clockwise rotations as r and counterclockwise rotations as R. For example, starting from configuration (S), by the rotation sequence r1R4r2R3 we reach the configuration (E). Now, starting from configuration (S), find the shortest way to reach configuration (T).  </p>
<p><img src="http://ww3.sinaimg.cn/mw690/bd582863gw1f3ys2yosrcj211q0eeq54.jpg" alt="Image">  </p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="#数据结构"></a>#数据结构</h1><p>定义Step</p>
<pre><code>typedef struct
{
    int r;//region
    int c;//clockwise
}Step;
</code></pre><p>定义链式栈</p>
<pre><code>typedef struct {
    int di;//距离 dis
    Step step;//一步
    int **pt;//走完这一步后的3*3表格数据
}ElementType;

typedef struct node {
    ElementType data;
    struct node *next;
}StackNode, *LinkStack;

void InitStack(LinkStack top) {
    top-&gt;next = NULL;
}

int IsEmpty(LinkStack top) {
    if(top-&gt;next == NULL) return TRUE;
    return FALSE;
}

int Push(LinkStack top, ElementType element) {
    ...//省略
}

int Pop(LinkStack top, ElementType *element) {
    ...//省略
}

void GetTop(LinkStack top, ElementType *element) {
       ...//省略
}

BOOL StackLoopEnd(LinkStack S) {
    ...//省略
}
</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a>#思路</h1><p>每次操作之后使得二组数组的’差距’越来越小，所以每一次操作应该是当前所有可能操作下的最优选择，并记录这步操作（入栈），如果执行到某一步，接下来的最优操作也无法缩短’差距’, 则回退到上一步，并删除这步操作（出栈），并且标记这时的棋盘状态为1（表示已经过），依此类推。。。  </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="#代码"></a>#代码</h1><p><a href="https://github.com/polarbearmaster/Liuliu2" target="_blank" rel="external">Github代码请戳我</a>, <strong>你的支持是北极熊继续学习并分享的动力!</strong></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="#尾声"></a>#尾声</h1><p>这是应聘遛遛iOS开发的时候需要做的两道算法题中的第二题。这一题花了我很多时间与精力。若没有🐧同学的支持以及就职于IBM的Will同学的启发，我也不可能完成这项任务。代码过程中参考了严老师的数据结构与算法。<br>Reference：<a href="http://www.liuliu.co/job-dev" target="_blank" rel="external">http://www.liuliu.co/job-dev</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;There’re 9 numbers in a 3 x 3 plane. We could only clockwise or counterclockwise rotate the four tiles around one of th
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Beta🐶下棋</title>
    <link href="blog.polarbearmaster.com/2016/05/16/%E9%A2%98%E7%9B%AE%E4%B8%80/"/>
    <id>blog.polarbearmaster.com/2016/05/16/题目一/</id>
    <published>2016-05-16T15:33:18.000Z</published>
    <updated>2017-04-19T15:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>机器人BetaGo现处于一个 8x8 的棋盘之中，棋盘中散落着一些棋子。BetaGo可以接收以下几种命令：  </p>
<pre><code>1. move n 
向前走n步 
2. turn left 
向左转 
3. turn right 
向右转 
4. turn back 
向后转 
</code></pre><p>BetaGo在每次移动之前，都会检查这一步会不会走出棋盘。如果会，BetaGo则留在原地，即棋盘的边缘。<br>如果BetaGo在移动的时候面前有棋子，那她会在移动的时候把这个棋子和之后相连的所有棋子都往前推一步。这可能会导致棋子掉出棋盘，但BetaGo一点也不在乎！<br>现在给出棋盘的初始状态和BetaGo收到的所有命令，求出棋盘的最终状态。<br>棋盘的初始状态：</p>
<pre><code>.....c..
.p..A..t
D..&gt;T.Pr
....aP.P
p.d.C...
.....p.R
........
........
</code></pre><p>以上数据对应的棋盘状态如下：<br><img src="http://ww2.sinaimg.cn/mw690/bd582863gw1f3xoj4e6i9j206d06edfz.jpg" alt=""></p>
<p>棋盘上的字母代表棋子， &gt; (大于号)表示BetaGo面向棋盘右边， &lt; （小于号）表示BetaGo面向棋盘左边， v （字母v）表示BetaGo面向棋盘下边， ^ （阶乘符号，键盘上数字6上面的符号）表示BetaGo面向棋盘上边。 . (点) 表示棋盘空余的格子<br>BetaGo收到的命令：</p>
<pre><code>move 1
turn right
move 2
turn left
move 2
move 3
move 3
turn left
move 1
move 2
turn back
move 1
turn left
move 1
turn left
move 1
move 1
turn back
turn right
move 3
turn left
move 4
turn left
move 5
turn right
move 2
turn right
move 9
turn right
turn right
move 2
turn back
move 1
turn right
move 3
turn right
move 1
turn right
move 1
turn right
move 1
turn left
move 1
turn left
move 4
</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a>#思路</h1><p>比较直接的想法是:<br>先写一个函数<strong>Move1</strong>，参数是一个8<em>8的数组，<br>返回值为void，这个函数计算了beta狗朝前走一步之后的棋局状态。函数中引用了beta狗的位置 (posX, posY)<br>其次写一个函数<em>*MoveN</em></em>, 参数是一个8＊8的数组和步数n，计算了beta狗朝前走n步后的棋局状态 </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="#代码"></a>#代码</h1><p><a href="https://github.com/polarbearmaster/Liuliu1" target="_blank" rel="external">Github代码请戳我</a>, <strong>你的支持是北极熊继续学习并分享的动力!</strong></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="#尾声"></a>#尾声</h1><p>这是应聘遛遛iOS开发的时候需要做的两道算法题中的第一题。我趁此复习了一下数据结构与算法，拿出严老师的书重新温习了下<br>Reference：<a href="http://www.liuliu.co/job-dev" target="_blank" rel="external">http://www.liuliu.co/job-dev</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;机器人BetaGo现处于一个 8x8 的棋盘之中，棋盘中散落着一些棋子。BetaGo可以接收以下几种命令：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. move n 
向前走n步 
2. turn left 
向左转 
3. turn rig
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>神兽镇楼</title>
    <link href="blog.polarbearmaster.com/2016/05/15/%E7%A5%9E%E5%85%BD/"/>
    <id>blog.polarbearmaster.com/2016/05/15/神兽/</id>
    <published>2016-05-15T09:09:57.000Z</published>
    <updated>2016-05-18T16:13:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/mw690/bd582863gw1f3wl5tc9q6j20hr0hxwh7.jpg" alt="北极熊"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/bd582863gw1f3wl5tc9q6j20hr0hxwh7.jpg&quot; alt=&quot;北极熊&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
