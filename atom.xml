<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr. Bear&#39;s home</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.polarbearmaster.com/"/>
  <updated>2017-11-19T11:51:11.000Z</updated>
  <id>blog.polarbearmaster.com/</id>
  
  <author>
    <name>Bear</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作回顾（3）</title>
    <link href="blog.polarbearmaster.com/2017/09/25/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE%EF%BC%883%EF%BC%89/"/>
    <id>blog.polarbearmaster.com/2017/09/25/工作回顾（3）/</id>
    <published>2017-09-25T01:58:57.000Z</published>
    <updated>2017-11-19T11:51:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>16年中的时候，无人机站上了风口。主流的价值观认为物联网是下一个浪潮。汽车/飞机 作为上一个工业时代的产物，如果能够通过各种传感器，智能联网（IOT），形成无人汽车，无人机等新产品，将彻底颠覆我们传统的社会组织形式。就这样，怀着对未来的憧憬，我加入了YUNEEC公司。</p>
<p>我参与的第一个项目是手持云台(Steadicam Volt)。这是YUNEEC公司与Tiffen公司合作推出的一款智能智能手机稳定器。App端实现并不复杂，我主要做的是蓝牙通讯（App &lt;-&gt; 手持云台）。<br>有2点值得一题：</p>
<ul>
<li>该项目从立项到交付耗时2年，主要是技术团队的人员变动以及需求的反复变化。</li>
<li>该项目已在kickstarter网站上成功众筹，目前已售出 $100,000。我们多名人员投入到设计，生产，研发环节。而双方仅有几名人员负责市场与销售。</li>
</ul>
<p>第二个项目是Dronelink（适用于px4飞控系统的工具包）。简单的说就是提供一个SDK工作包，让使用我们产品的企业在这套工具的基础上做2次开发。这个项目大概持续了近一年时间。开发团队由上海和苏黎世双方团队合作开发。<br>几点总结：</p>
<ul>
<li>架构 - 开始的时候无从下手，借鉴了dji的框架，开发到后面越来越流畅，再次印证了一句古话，万事开头难。</li>
<li>沟通 - 语言，时差，陌生人等因素均造成了双方沟通上的障碍。事实证明，电话沟通 &gt; 微信 &gt; 邮件。而当瑞士工程师来上海出差，我们组织团队聚餐，明显感到双方的隔阂少了很多。</li>
<li>新人 - 刚组建团队的时候找不到资源，所以招聘了2位应届生。由于项目比较急，所以他们没有常规的适应时间，必须快速进入项目。我给他们做了一些指导并帮助他们搭建了开发环境。后来想想，当时如果能抽出部分时间，给他们做一些项目背景以及行业背景知识的普及会更好一些。</li>
</ul>
<p>第三个项目是firebird（火鸟 - 一款固定翼飞机）。这个项目从去年年底快持续1年了。主要功能也挺简单，让用户看到图传，飞机的参数等等。由上海团队和昆山团队联合开发。<br>几点总结：</p>
<ul>
<li>集成 - 由于跨团队／多模块 协同开发，又涉及到软硬件，一旦出现bug非常难以定位。</li>
<li>人员 - 由于取消了年终奖以及部门裁员等原因， 导致团队凝聚力，执行力下降。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;16年中的时候，无人机站上了风口。主流的价值观认为物联网是下一个浪潮。汽车/飞机 作为上一个工业时代的产物，如果能够通过各种传感器，智能联网（IOT），形成无人汽车，无人机等新产品，将彻底颠覆我们传统的社会组织形式。就这样，怀着对未来的憧憬，我加入了YUNEEC公司。&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工作回顾（2）</title>
    <link href="blog.polarbearmaster.com/2017/09/21/%E5%B7%A5%E4%BD%9C%E5%9B%9E%E9%A1%BE%EF%BC%882%EF%BC%89/"/>
    <id>blog.polarbearmaster.com/2017/09/21/工作回顾（2）/</id>
    <published>2017-09-21T04:06:04.000Z</published>
    <updated>2017-11-19T12:21:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>14年底，智能家居正在风口上，国内像小米，海尔，国外如google，amazon等重量级玩家纷纷入场。我亦加入了新组建的霍尼韦尔智能家居部门（Honeywell Smart Home），有幸一睹大战风采。</p>
<p>在霍尼的一年半时间里，我主要做了2件事。</p>
<blockquote>
<p>张志东很值得尊敬，一是其技术上的炉火纯青，即便是他的对手，都对这点佩服得五体投地。QQ的架构设计源于1998年，截止到2009年8月，QQ用户数从之前设计的百万级到现在的数以亿计，整个架构还在适用。 - 百度百科  </p>
</blockquote>
<p>前半段，担任 iOS 客户端主力开发工程师。<br>我们团队完成了App 的2.0，3.0，4.0 共计3个大版本的开发工作，从无到有积累了几万用户。这段时间是我个人技术成长高速期。业务的不断变化，对整个App的架构提出更高的要求。同时，要非常感谢资深软件开发工程师Carl同学的指点。我们共同设计了 动画框架，以及（多）任务处理系统。</p>
<p>对于动画框架，我们有2点需要</p>
<ul>
<li>抽象 - 多个模块都要用到，需要它高度抽象，简单好用</li>
<li>酷炫 - 模仿雅虎天气，基于openGL，我们开发了一套粒子系统。</li>
</ul>
<p>对于任务处理系统，我们需要</p>
<ul>
<li>轮询 - 早期硬件回复的较慢，有时甚至会超时</li>
<li>批量 - 对于企业级／高级用户的需求</li>
</ul>
<hr>
<p>后半段，担任 Scrum Master（有点像传统的项目经理)。</p>
<blockquote>
<p>什么叫真正的刚需？其实就是三件事：极大提升效率，极大降低成本和极大提升体验。- 程浩  </p>
</blockquote>
<p>我不再写代码了，主要工作是组织每日站会，需求评审会，回顾会；提交测试／发布计划；与产品经理／业务部门／兄弟部门团队沟通等。当中我们经历了一个大版本发布，某个用户故事（user story）横跨2个sprint，造成燃尽图迟迟下不来；Sprint过程中，由于业务需求发生变化，最终导致整个发布延期。我们也实践了 iOS 开发 &amp; Android开发结对编程, 测试驱动（TDD），单元测试等创新。开始的时候是有阻力的，最后效果很不错，Sprint的完成度很高，大家也就乐于接受了。</p>
<blockquote>
<p>精益创业的本质就是不断试错，快速试错，低成本快速试错。- 《精益创业》  </p>
</blockquote>
<p>个人认为scrum master本质上是一个服务型角色，旨在提高团队工作效率，排除沟通障碍，预测潜在风险。敏捷开发的理念恰恰符合精益创业的原则 - 小步试错，迅速迭代。在管理工具上，我们选择了JIRA和Confluence，JIRA是一个杰出的项目管理工具，便于我们监控项目过程，分析项目质量。Confluence是在线文档管理工具，虽说敏捷原则是个人交互重于合同文档，但在实际开发过程中，我们发现维护一份在线文档是十分必要的。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/bd582863gy1flnnspdxdij207v05i751.jpg" alt="image"></p>
<blockquote>
<p>软件工程也要做到：多，快，好，省 - 资深项目经理 eric 同学  </p>
</blockquote>
<p>多 - 用户故事点完成数多<br>快 - 开发速率快<br>好 - 软件质量好<br>省 - 开发成本低</p>
<p>基于公司和部门的战略，我把关注重点放在 <strong>好 快</strong>。<br>通过半年多的努力，我们把严重线上bug率降到了1%以下，并且把每个sprint的完成量维持在稳定水准。</p>
<p>15年中的时候，我因私人原因离开了公司 - 谨以此文献给共同奋斗过500个日日夜夜的团队。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;14年底，智能家居正在风口上，国内像小米，海尔，国外如google，amazon等重量级玩家纷纷入场。我亦加入了新组建的霍尼韦尔智能家居部门（Honeywell Smart Home），有幸一睹大战风采。&lt;/p&gt;
&lt;p&gt;在霍尼的一年半时间里，我主要做了2件事。&lt;/p&gt;
&lt;b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>还原：微信红包的背后</title>
    <link href="blog.polarbearmaster.com/2017/06/14/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85/"/>
    <id>blog.polarbearmaster.com/2017/06/14/微信抢红包/</id>
    <published>2017-06-14T12:33:59.000Z</published>
    <updated>2017-11-19T11:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fgndjkz8l8j20bo08sglu.jpg" alt="微信红包"></p>
<blockquote>
<p>作为一枚前 iOS 程序猿，平常的 App 已越来越不能吸引我的兴趣，在这一行干得越久，越能体会到苹果提供的 Foudation，UIKit 等系统框架的强大，它能使一名初学者几乎毫不费力地独立完成一个 App，譬如几天前在 2017 WWDC 苹果开发者大会上 苹果公司CEO 库克声称最年轻的 iOS 仅仅10岁，却有5款作品上架 App Store。那么 iOS 系统底层究竟是怎样的呢？移动互联网巨头微信的框架体系又是怎样使他支持5亿用户的呢？怀着强烈的好奇心，本人在业余时间学习了iOS逆向的基本技巧，乘热打铁，把玩了下微信抢红包。</p>
</blockquote>
<p><strong>任务分解</strong></p>
<ul>
<li>监听到新消息</li>
<li>判断是红包</li>
<li>点击红包</li>
<li>领取红包</li>
</ul>
<blockquote>
<p>开始</p>
</blockquote>
<h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul>
<li>Reveal</li>
<li>Cycript</li>
<li>Hopper Disassembler v4</li>
<li>LLDB</li>
<li>debugserver</li>
<li>dumpdecrypted</li>
<li>dyld_decache</li>
</ul>
<h1 id="监听到新消息"><a href="#监听到新消息" class="headerlink" title="监听到新消息"></a>监听到新消息</h1><p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fgndss9kokj208w05kt9l.jpg" alt="reveal"></p>
<p>通过 cycript 找到对应 <em>WCPayC2CMessageCellView</em> 的 视图控制器 （微信的设计必然符合苹果提倡的MVC架构）</p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgndz4dmzsj212m058tai.jpg" alt="cycript"> </p>
<p>class dump 出微信所有的头文件后， </p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgne7vvxurj205o0amjru.jpg" alt="class dump"> </p>
<p>找到 <em>BaseMsgContentViewController</em>，<br>搜索 <em>protocol</em>, <em>msg</em>，<em>content</em>，<em>delegate</em> 等关键词，发现</p>
<p><code>@property(nonatomic) __weak id &lt;BaseMsgContentDelgate&gt; m_delegate; // @synthesize m_delegate;</code></p>
<p>再次通过 cycript 查看该属性</p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgnebxsfyxj20fo00xdfr.jpg" alt="cycript"> </p>
<p>打开 <em>WeixinContentLogicController</em> 头文件，<br>尝试了几个容易被怀疑的方法诸如</p>
<p><code>- (void)AddMsg:(id)arg1 MsgWrap:(id)arg2;</code></p>
<p>效果均不理想。<br>让我们换个角度思考，查看它的父类 <em>BaseMsgContentLogicController</em></p>
<p><img src="http://wx4.sinaimg.cn/mw690/bd582863gy1fgnepb013mj203c03cq34.jpg" alt=""></p>
<p>几次尝试后找到下面方法</p>
<p><code>- (void)modMsgWithoutNotify:(id)arg1;</code></p>
<p>通过 Hooper Disassembler 查看其内存代码</p>
<p><img src="http://wx4.sinaimg.cn/mw690/bd582863gy1fgnev3df5tj20jn0263zw.jpg" alt="hooper"></p>
<p>请出 lldb 附加 debugserver 作进一步分析：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fgnext93fpj213g0a640d.jpg" alt="lldb"></p>
<p>至此，我们找到了关键类 <em>CMessageMgr</em>， 以及之后要用到的消息结构体 <em>CMessageWrap</em></p>
<p>查看 <strong>CMessageMgr</strong> 头文件，反（挺）复（明）尝（显）试（的），找到我们需要 hook 的函数</p>
<p><strong><code>- (void)AsyncOnAddMsg:(id)arg1 MsgWrap:(id)arg2;</code></strong></p>
<hr>
<h1 id="判断是红包"><a href="#判断是红包" class="headerlink" title="判断是红包"></a>判断是红包</h1><p>趁热打铁，查看 <strong>CMessageWrap</strong> 头文件，发现可疑属性2枚，</p>
<p><strong><code>@property(nonatomic) unsigned long m_uiMessageType; // @synthesize m_uiMessageType;</code></strong></p>
<p><strong><code>@property(retain, nonatomic) NSString *m_nsContent; // @synthesize m_nsContent;</code></strong></p>
<p>lldb+debugserver 调试<br>发现 type 为49， content 中包含wxpay://<br>此处省略100字，有图有真相</p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgnf73knxij213k0fegqb.jpg" alt="红包消息"></p>
<hr>
<h1 id="点击红包"><a href="#点击红包" class="headerlink" title="点击红包"></a>点击红包</h1><p>首先 通过 reveal 定位到 <em>WCPayC2CMessageCellView</em> （图片见上方）<br>查看头文件，然并卵，查看其父类 <em>WCPayBaseMessageCellView</em><br>找到 </p>
<p><code>- (void)onTouchUpInside;</code></p>
<p>hooper 静态分析 </p>
<p><code>[BaseMsgContentViewController tapAppNodeView:]</code></p>
<p>反复阅读其汇编代码后 仔细分析后找到可疑函数</p>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fgnfhyrb8qj210c0i00zu.jpg" alt="startReceiveRedEnvelopesLogic:Data:"></p>
<p>继续分析</p>
<p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fgnfjpy75pj215o0f6n8z.jpg" alt="WCRedEnvelopesReceiveControlLogic"></p>
<p>查看 <em>WCRedEnvelopesReceiveControlLogic</em> 头文件，<br>反复尝试（此处省略500字。。。）后发现</p>
<p><code>- (void)OnReceiverQueryRedEnvelopesRequest:(id)arg1 Error:(id)arg2;</code></p>
<p>hooper 分析，<br>该方法比较复杂，仔细排查后，把注意力放到左边，</p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgnfqzqda3j20nk0nrwn0.jpg" alt="WCRedEnvelopesReceiveControlLogic"></p>
<p>通过 <em>WCBizUti</em> 解析 <em>nativeUrl</em>，获取关键信息，如<br><em>msgType</em>, <em>sendId</em>, <em>channelId</em>, <em>nativeUrl</em><br>封装在一个字典结构体中，最后调用 <em>QueryRedEnvelopesDetailRequest</em></p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fgnftxht3bj20zy0gkapo.jpg" alt="WCRedEnvelopesReceiveControlLogic"></p>
<p>至此，我们得到关键类 <strong>WCRedEnvelopesLogicMgr</strong> 以及关键函数<br><strong><code>- (void)QueryRedEnvelopesDetailRequest:(id)arg1;</code></strong></p>
<hr>
<h1 id="领取红包"><a href="#领取红包" class="headerlink" title="领取红包"></a>领取红包</h1><p>老套路， reveal 打头阵</p>
<p><img src="http://wx4.sinaimg.cn/mw690/bd582863gy1fgnfwb3m0jj208w05ewf9.jpg" alt="WCRedEnvelopesReceiveHomeView"></p>
<p>查看 WCRedEnvelopesReceiveHomeView 头文件，<br>发现</p>
<p><code>id &lt;WCRedEnvelopesReceiveHomeViewDelegate&gt; m_delegate;</code></p>
<p>同上文所述，定位到 WCRedEnvelopesReceiveControlLogic，<br>尝试</p>
<p><code>- (void)WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes;</code></p>
<p>hooper 跟进<br>和打开红包很像，也是由 <em>WCBizUti</em> 解析 <em>nativeUrl</em>, 取关键信息如<br><em>msgType</em>, <em>sendId</em>, <em>channelId</em>, <em>nickName</em>, <em>headImg</em>, <em>nativeUrl</em>, <em>sessionUserName</em>, <em>timingIdentifier</em><br>, 再把他们封装一个字典结构体中<br>最后调用 <em>checkHongbaoOpenLicense:acceptCallback:denyCallback:</em></p>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fgnghlhdn9j20qs065abw.jpg" alt="checkHongbaoOpenLicense:acceptCallback:denyCallback:"></p>
<p>由于该方法的参数直接从内存中读取的，无法静态分析，下面还是请出我们的终极武器 lldb</p>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fgngaq3vxhj20xq0abjt9.jpg" alt="lldb"></p>
<p>hooper 跳转地址 <em>0x140CA91</em> (0x014d7a91 减去 0x000cb000（基地址))</p>
<p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fgng9en2ksj20j30e4q85.jpg" alt="checkHongbaoOpenLicense:acceptCallback:denyCallback:"></p>
<p>我们得到了关键类 <strong>WCRedEnvelopesLogicMgr</strong> 和 hook的函数 <strong><code>- (void)OpenRedEnvelopesRequest:(id)arg1;</code></strong></p>
<p>PS: 一张图看懂 block 的结构体 </p>
<p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fgngcgfa3ej20j808q75t.jpg" alt="block"></p>
<hr>
<h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fgnjbee5vug20a006o1kx.gif" alt="lldb"> </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微信作为国内即时通讯的巨头，其平台强大，结构复杂，代码量大，它的设计相当考究，模块划分十分清晰，<br>仅仅是浏览他的头文件就能给我们很多启示，对于有意涉足即时通讯的开发者，相当值得借鉴。</p>
<h1 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h1><p><a href="https://item.jd.com/11670145.html" target="_blank" rel="external">iOS应用逆向工程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/mw690/bd582863gy1fgndjkz8l8j20bo08sglu.jpg&quot; alt=&quot;微信红包&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为一枚前 iOS 程序猿，平常的 App 已越来越不能吸
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分析一个奇怪的程序</title>
    <link href="blog.polarbearmaster.com/2017/04/19/%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>blog.polarbearmaster.com/2017/04/19/分析一个奇怪的程序/</id>
    <published>2017-04-19T15:27:06.000Z</published>
    <updated>2017-04-20T14:47:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>分析下面的程序，思考：这个程序可以正确返回吗？</p>
</blockquote>
<pre><code>assume cs:code
code segment

        mov    ax,4c00h
        int 21h

start:    mov ax,0
    s:    nop
        nop

        mov di,offset s
        mov si,offset s2
        mov ax,cs:[si]
        mov cs:[di],ax

   s0:    jmp short s

   s1:    mov ax,0
        int 21h
        mov ax,0

   s2:    jmp short s1
        nop

code ends
end start
</code></pre><h2 id="查看CPU指令"><a href="#查看CPU指令" class="headerlink" title="查看CPU指令"></a>查看CPU指令</h2><p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fetilmteo5j20w00skwor.jpg" alt="image"></p>
<p><img src="http://wx1.sinaimg.cn/mw690/bd582863gy1fetio409nnj21kw04lwgc.jpg" alt="image"></p>
<p>##指令执行顺序</p>
<ol>
<li><em>ip＝5</em>，执行代码中的     <code>mov ax,0</code></li>
<li>按<em>-t</em> 一直执行到<em>0014</em>     <code>mov cs:[di],ax</code></li>
<li>执行指令<em>0016</em>        <code>jmp short s (jmp 0008)</code></li>
<li>执行指令                <code>jmp 0000</code></li>
<li>执行指令<em>0000</em>            <code>mov ax,4c00h</code></li>
<li>执行指令<em>0003</em>            <code>int 21h</code></li>
</ol>
<p><img src="http://wx3.sinaimg.cn/mw690/bd582863gy1fetie4laxhj20zr0mgtbm.jpg" alt="image"></p>
<p>#结论：程序可以正常退出</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><pre><code>mov di,offset s
mov si,offset s2
mov ax,cs:[si]
mov cs:[di],ax
</code></pre><p><strong>这段代码的作用是将指令 s2 对应的指令当作数据存储 位于指令 s1 对应的地址处</strong></p>
<p>指令s2 对应的机器代码为 <em>EBF6</em><br>其中 <strong>EB</strong> 代表移动， <strong>F6</strong> 代表位移。</p>
<p><strong>执行完这条指令后，我们查看指令（按<code>-u cs:0</code>） 发现原本指令0C8D:<em>0008</em> 处的<em>90</em>（NOP）成为了 <em>EBF6</em> (<code>jmp 0000</code>)</strong></p>
<p><img src="http://wx4.sinaimg.cn/mw690/bd582863gy1fetiqacjqij20mr0egabg.jpg" alt="image"></p>
<hr>
<h3 id="转移指令的作用"><a href="#转移指令的作用" class="headerlink" title="转移指令的作用"></a>转移指令的作用</h3><blockquote>
<ol>
<li>从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓存器;</li>
<li>(IP)=(IP)+所读取指令的长度，从而指向下一条指令;</li>
<li>执行指令。转到 1， 重复这个过程</li>
</ol>
</blockquote>
<p>F6是负值</p>
<p><code>Not(F6=11110110) + 1 = 1010b = 10</code></p>
<p><strong>即ip向前移动10个字节</strong></p>
<p>实际上读取指令 <code>s2: jmp short s1</code> 到缓存后</p>
<p>ip = <em>0022</em></p>
<p>之后 CPU 从缓存中读取s2指令，跳转到s1：<em>0018</em>处</p>
<p>同样可以得到 <strong>ip向前移动10个字节</strong> </p>
<p><code>22h-18h = 0ah = 10</code></p>
<hr>
<p>接下来 CPU 执行指令 <code>0016 s0:jmp short s</code></p>
<p>再跳转到指令s处</p>
<p>同上，CPU 读取指令 “ip向前移动10位” 到缓存中,</p>
<p>由于该指令存放在16位寄存器ax中，<strong>长度为2个字节</strong> </p>
<p>接着ip指向地址：<strong>000A</strong>，</p>
<p>接下来cpu从缓存中读取指令并执行，即<br><code>0ah － 10 ＝ 0</code></p>
<p>所以ip＝0，接着执行<br><code>mov ax，4c00h;
 int 21h;</code></p>
<p>#程序正常退出！！！</p>
<p><img src="http://wx2.sinaimg.cn/mw690/bd582863gy1fetitjlcpyj20go0ciwhd.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分析下面的程序，思考：这个程序可以正确返回吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;assume cs:code
code segment

        mov    ax,4c00h
        int 21h

s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>旋转棋盘</title>
    <link href="blog.polarbearmaster.com/2016/05/17/%E9%A2%98%E7%9B%AE%E4%BA%8C/"/>
    <id>blog.polarbearmaster.com/2016/05/17/题目二/</id>
    <published>2016-05-17T14:50:20.000Z</published>
    <updated>2016-05-22T03:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>There’re 9 numbers in a 3 x 3 plane. We could only clockwise or counterclockwise rotate the four tiles around one of the four points, I II III and IV. R1, R2, R3, R4 and r1, r2, r3, r4 are corresponding to the 8 kinds of rotation, where we mark clockwise rotations as r and counterclockwise rotations as R. For example, starting from configuration (S), by the rotation sequence r1R4r2R3 we reach the configuration (E). Now, starting from configuration (S), find the shortest way to reach configuration (T).  </p>
<p><img src="http://ww3.sinaimg.cn/mw690/bd582863gw1f3ys2yosrcj211q0eeq54.jpg" alt="Image">  </p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="#数据结构"></a>#数据结构</h1><p>定义Step</p>
<pre><code>typedef struct
{
    int r;//region
    int c;//clockwise
}Step;
</code></pre><p>定义链式栈</p>
<pre><code>typedef struct {
    int di;//距离 dis
    Step step;//一步
    int **pt;//走完这一步后的3*3表格数据
}ElementType;

typedef struct node {
    ElementType data;
    struct node *next;
}StackNode, *LinkStack;

void InitStack(LinkStack top) {
    top-&gt;next = NULL;
}

int IsEmpty(LinkStack top) {
    if(top-&gt;next == NULL) return TRUE;
    return FALSE;
}

int Push(LinkStack top, ElementType element) {
    ...//省略
}

int Pop(LinkStack top, ElementType *element) {
    ...//省略
}

void GetTop(LinkStack top, ElementType *element) {
       ...//省略
}

BOOL StackLoopEnd(LinkStack S) {
    ...//省略
}
</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a>#思路</h1><p>每次操作之后使得二组数组的’差距’越来越小，所以每一次操作应该是当前所有可能操作下的最优选择，并记录这步操作（入栈），如果执行到某一步，接下来的最优操作也无法缩短’差距’, 则回退到上一步，并删除这步操作（出栈），并且标记这时的棋盘状态为1（表示已经过），依此类推。。。  </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="#代码"></a>#代码</h1><p><a href="https://github.com/polarbearmaster/Liuliu2" target="_blank" rel="external">Github代码请戳我</a>, <strong>你的支持是北极熊继续学习并分享的动力!</strong></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="#尾声"></a>#尾声</h1><p>这是应聘遛遛iOS开发的时候需要做的两道算法题中的第二题。这一题花了我很多时间与精力。若没有🐧同学的支持以及就职于IBM的Will同学的启发，我也不可能完成这项任务。代码过程中参考了严老师的数据结构与算法。<br>Reference：<a href="http://www.liuliu.co/job-dev" target="_blank" rel="external">http://www.liuliu.co/job-dev</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;There’re 9 numbers in a 3 x 3 plane. We could only clockwise or counterclockwise rotate the four tiles around one of th
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Beta🐶下棋</title>
    <link href="blog.polarbearmaster.com/2016/05/16/%E9%A2%98%E7%9B%AE%E4%B8%80/"/>
    <id>blog.polarbearmaster.com/2016/05/16/题目一/</id>
    <published>2016-05-16T15:33:18.000Z</published>
    <updated>2017-04-19T15:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>机器人BetaGo现处于一个 8x8 的棋盘之中，棋盘中散落着一些棋子。BetaGo可以接收以下几种命令：  </p>
<pre><code>1. move n 
向前走n步 
2. turn left 
向左转 
3. turn right 
向右转 
4. turn back 
向后转 
</code></pre><p>BetaGo在每次移动之前，都会检查这一步会不会走出棋盘。如果会，BetaGo则留在原地，即棋盘的边缘。<br>如果BetaGo在移动的时候面前有棋子，那她会在移动的时候把这个棋子和之后相连的所有棋子都往前推一步。这可能会导致棋子掉出棋盘，但BetaGo一点也不在乎！<br>现在给出棋盘的初始状态和BetaGo收到的所有命令，求出棋盘的最终状态。<br>棋盘的初始状态：</p>
<pre><code>.....c..
.p..A..t
D..&gt;T.Pr
....aP.P
p.d.C...
.....p.R
........
........
</code></pre><p>以上数据对应的棋盘状态如下：<br><img src="http://ww2.sinaimg.cn/mw690/bd582863gw1f3xoj4e6i9j206d06edfz.jpg" alt=""></p>
<p>棋盘上的字母代表棋子， &gt; (大于号)表示BetaGo面向棋盘右边， &lt; （小于号）表示BetaGo面向棋盘左边， v （字母v）表示BetaGo面向棋盘下边， ^ （阶乘符号，键盘上数字6上面的符号）表示BetaGo面向棋盘上边。 . (点) 表示棋盘空余的格子<br>BetaGo收到的命令：</p>
<pre><code>move 1
turn right
move 2
turn left
move 2
move 3
move 3
turn left
move 1
move 2
turn back
move 1
turn left
move 1
turn left
move 1
move 1
turn back
turn right
move 3
turn left
move 4
turn left
move 5
turn right
move 2
turn right
move 9
turn right
turn right
move 2
turn back
move 1
turn right
move 3
turn right
move 1
turn right
move 1
turn right
move 1
turn left
move 1
turn left
move 4
</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="#思路"></a>#思路</h1><p>比较直接的想法是:<br>先写一个函数<strong>Move1</strong>，参数是一个8<em>8的数组，<br>返回值为void，这个函数计算了beta狗朝前走一步之后的棋局状态。函数中引用了beta狗的位置 (posX, posY)<br>其次写一个函数<em>*MoveN</em></em>, 参数是一个8＊8的数组和步数n，计算了beta狗朝前走n步后的棋局状态 </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="#代码"></a>#代码</h1><p><a href="https://github.com/polarbearmaster/Liuliu1" target="_blank" rel="external">Github代码请戳我</a>, <strong>你的支持是北极熊继续学习并分享的动力!</strong></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="#尾声"></a>#尾声</h1><p>这是应聘遛遛iOS开发的时候需要做的两道算法题中的第一题。我趁此复习了一下数据结构与算法，拿出严老师的书重新温习了下<br>Reference：<a href="http://www.liuliu.co/job-dev" target="_blank" rel="external">http://www.liuliu.co/job-dev</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;机器人BetaGo现处于一个 8x8 的棋盘之中，棋盘中散落着一些棋子。BetaGo可以接收以下几种命令：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. move n 
向前走n步 
2. turn left 
向左转 
3. turn rig
    
    </summary>
    
    
  </entry>
  
</feed>
